# 7장 신뢰성 있는 데이터 전달
카프카를 사용하여 신뢰성을 검증하는 방법에 대해서 알아가보자 <br>

## 7.1 신뢰성 보장
제일 잘 알려진 신뢰성 보장은 RDBMS 에서 지원하는 ACID 일 것이다 <br>
- A(Atomicity): 원자성
- C(Consistency): 일관성
- I(Isolation): 격리성
- D(Durability): 지속성

어떠한 데이터베이스가 ACID 를 준수한다고 하면, 트랜잭션 처리 관련해서 어떠한 행동을 보장한다는 의미가 된다 <br>

신뢰성 있는 어플리케이션을 개발하고자 한다면 Kafka 에서 제공하는 보장을 이해하는 것은 필수적이다.
- Kafka 는 파티션 안의 메시지들 간에 순서를 보장한다.
- 클라이언트가 쓴 메시지는 InSync 레플리카의 파티션에 쓰여진 뒤에야 '커밋' 된 것으로 간주된다 (디스크 flush 까지는 필요 없다)
- 커밋된 메시지들은 최소 1개의 작동 가능한 레플리카가 남아 있는 한 유실되지 않는다.
- 컨슈머는 커밋된 메시지만 읽을 수 있다.

위처럼 기본적인 보장들은 제공하지만, 신뢰성 시스템을 구축하는 데는 트레이드 오프가 있는 법이다 <br>
보통 신뢰성이냐, 일관성이냐, 가용성이냐 높은 처리량이냐 이러한 고민을 하게 된다 <br><br>

## 7.2 복제
카프카의 복제 메커니즘은 파티션별로 다수의 레플리카를 유지한다는 특성과 함께 카프카의 신뢰성 보장의 핵심이라고 할 수 있다 <br>
하나의 메시지를 여러 개의 레플리카에 씀으로써 카프카는 crash 가 나더라도 메시지의 지속성을 유지한다 <br>

하나의 파티션은 하나의 디스크에 저장되며, 저장된 이벤트들의 순서를 보장하며, 파티션은 온라인 상태거나 오프라인 상태일 수 있다 <br>
각 파티션은 다수의 레플리카를 가질 수 있으며, 그 중 하나가 리더가 된다 <br>
️🖐🏽브로커 개수에 따라서 레플리카가 존재하며, 리더 브로커에 있는 토픽의 파티션이 리더가 된다로 이해를 했는데 이부분이 맞는지 체크하기 <br>

모든 이벤트들은 리더 레플리카에 쓰여지며, 리더 리플레카에서 읽혀진다, 다른 레플리카들은 단순히 리더와 동기화를 맞추면서 최신 이벤트를 복사해 오기만 하면 된다 <br>
리더가 crash 되면, 인-싱크 레플리카 중 하나가 새 리더가 된다 <br><br>


## 7.3 브로커 설정
메시지 저장 신뢰성 관련된 카프카의 작동을 변경시키는 브로커의 설정 매개변수는 세 개가 있다

### 7.3.1 복제 팩터
토픽을 생성할 때 복제 팩터를 설정한다 (replication.factor) <br>
자동으로 생성될 경우 브로커의 default.replication.factor 설정에 잡힌대로 생성을 한다 <br>

복제 팩터 설정을 3이라고 한다면, 3개의 카프카 브로커가 있을 경우 3개 브로커 전체에 토픽이 복제가 된다는 뜻이다 <br>
ex) 카프카 브로커5개, 복제 팩터 3개 -> 카프카 브로커 5개중 3개의 브로커에만 토픽이 복제가 된다 <br>

복제 팩터가 클수록 가용성과 신뢰성은 늘어나고 장애가 발생할 확률은 줄어든다 <br>
하지만 그 만큼 메시지를 저장할 디스크 공간이 필요하다는 이야기도 된다 <br>
기본적으로, 가용성과 하드웨어 사용량 사이에 트레이드오프가 있는 것이다 <br>

그렇다면 토픽에 몇개의 복제 팩터가 적절한지 모범 사례 설정을 보자 <br>
- 가용성: 레플리카 수가 많을 수록 가용성은 늘어난다
- 지속성: 레플리카 수가 많을 수록 데이터 유실 가능성이 줄어든다.
- 처리량: 레플리카가 추가될 때 마다 브로커간 트래픽 역시 늘어난다. 
- 종단 지연: 쓰여진 메시지를 컨슈머가 읽으려면 InSync 설정에 잡힌 브로커(레플리카)에 복제가 되어야한다. -> 느려진다.
- 비용: 더 많은 레플리카를 가질수록 저장소와 네트워크에 들어가는 비용 역시 증가한다.

실제 레플리카가 존재하는 위치 역시 중요하다 <br>
같은 랙에 설치되어 있는데 랙이 오작동 할경우 해당 파티션은 사용할 수 없다 <br>
broker.rack 브로커 설정 매겨변수에 브로커 별로 서로 다른 이름을 잡아줄 것을 권장한다 <br>


### 7.3.2 언클린 리더 선출
위 설정은 브로커 단위에서만 가능하다(unclean.leader.election.enable=false (default))<br>

파티션의 리더가 사용 불가능 일 경우, 인-싱크 레플리카 중 하나가 새 리더가 된다 <br>
커밋된 데이터에 아무런 유실이 없음을 보장한다는 점에서 이러한 리더 선출을 '클린' 하다고 부른다 <br>

우리가 아웃-오브 싱크 레플리카(동기화X) 리더가 될 수 있도록 허용할 경우 데이터 유실과 일관성 깨짐의 위험성이 있다 <br>
그렇지 않을 경우, 파티션이 다시 온라인 상태가 될 때까지 원래 리더가 복구되는 것을 기다려야 하는 만큼 가용성은 줄어든다 <br>

-> unclean.leader.election.enable=false default 설정을 권장한다 <br>
불가피한 상황이 왔을 경우 true 로 변경 후 나중에 안정화가 되면 false 로 바꾸는 것이 권장됨. <br>


### 7.3.3 최소 인-싱크 레플리카




### 7.3.4 레플리카를 인-싱크 상태로 유지하기



### 7.3.5 디스크에 저장하기






































